
#' Source and Concept Vocabularies -- Output Generation
#'
#' Using the tabular output generated by `scv_process`, this function will build a graph to
#' visualize the results. Each function configuration will output a bespoke ggplot. Theming can
#' be adjusted by the user after the graph has been output using `+ theme()`. Most graphs can
#' also be made interactive using `make_interactive_squba()`
#'
#' @param process_output *tabular input* | the output of the `scv_process` function
#' @param code_type *string* | the type of code that is being used in the analysis, either `source` or `cdm`;
#'                  should match the code_type that was defined when running `scv_process`
#' @param filter_concept *(integer or string) or vector* | choose concept from the concept_set provided in
#'                       `scv_process` to filter the output; used for all inputs EXCEPT `ss_exp_cs`, `ss_exp_la`,
#'                       and `ss_anom_cs` (when jaccard_index is FALSE)
#' @param filter_mapped *(integer or string) or vector* | choose mapped concept from those associated with the
#'                      concept_id provided in `filter_concept`; options can be found in the `source_concept_id` column
#'                      of `scv_process`; used for `ms_anom_la`
#' @param num_codes *integer* | the number of top codes of code_type that should be displayed in the analysis
#'
#'                  used for `ss_exp_cs` and `ss_anom_cs`
#' @param num_mappings *integer* | the number of top mappings that should be displayed for each code of code_type
#'
#'                     used for `ss_exp_cs`, `ss_exp_la`, `ms_exp_la`, `ss_anom_cs`, `ms_anom_cs`
#' @param vocab_tbl *tabular input* | OPTIONAL: the location of an external vocabulary table containing concept names for
#'                  the provided codes. if not NULL, concept names will be available in either a reference
#'                  table or in a hover tooltip
#'
#' @return a graph to visualize the results from `scv_process` based on the parameters provided
#'
#'         in some cases, an additional reference table with summary information about the codes
#'         included in the graph
#'
#' @example inst/example-scv_process_output.R
#'
#' @export
#'
scv_output <- function(process_output,
                       code_type,
                       #facet = NULL,
                       filter_concept = NULL,
                       filter_mapped = NULL,
                       num_codes = 10,
                       num_mappings = 25,
                       vocab_tbl = NULL){

  # extract output function
  output_function <- process_output %>% collect() %>% ungroup() %>% distinct(output_function) %>% pull()

  if(output_function != 'scv_ss_anom_la'){

   if(output_function == 'scv_ss_anom_cs' && !is.null(filter_concept)){

     if('character' %in% class(process_output$concept1)){
       cid1_vocab_join <- 'concept_code'
     }else{cid1_vocab_join <- 'concept_id'}

     if('character' %in% class(process_output$concept2)){
       cid2_vocab_join <- 'concept_code'
     }else{cid2_vocab_join <- 'concept_id'}

      rslt_cid <- join_to_vocabulary(tbl = process_output,
                                     vocab_tbl = vocab_tbl,
                                     col = 'concept1',
                                     vocab_col = cid1_vocab_join) %>%
        rename('concept1_name' = 'concept_name')

      rslt_scid <- join_to_vocabulary(tbl = process_output,
                                      vocab_tbl = vocab_tbl,
                                      col = 'concept2',
                                      vocab_col = cid2_vocab_join) %>%
        rename('concept2_name' = 'concept_name')

      process_output <- process_output %>%
        left_join(rslt_cid %>% distinct(concept1, concept1_name)) %>%
        left_join(rslt_scid %>% distinct(concept2, concept2_name))
    }else{

      if('character' %in% class(process_output$concept_id)){
        cid_vocab_join <- 'concept_code'
      }else{cid_vocab_join <- 'concept_id'}

      if('character' %in% class(process_output$source_concept_id)){
        scid_vocab_join <- 'concept_code'
      }else{scid_vocab_join <- 'concept_id'}

      rslt_cid <- join_to_vocabulary(tbl = process_output,
                                     vocab_tbl = vocab_tbl,
                                     col = 'concept_id',
                                     vocab_col = cid_vocab_join)

      rslt_scid <- join_to_vocabulary(tbl = process_output,
                                      vocab_tbl = vocab_tbl,
                                      col = 'source_concept_id',
                                      vocab_col = scid_vocab_join) %>%
        rename('source_concept_name' = 'concept_name')

    process_output <- process_output %>%
      left_join(rslt_cid %>% distinct(concept_id, concept_name)) %>%
      left_join(rslt_scid %>% distinct(source_concept_id, source_concept_name))
    }
  }else{
    process_output <- process_output
  }

  if('age_grp' %in% colnames(process_output)){
    facet <- 'age_grp'
  }else{facet <- NULL}

  ## Run output functions
  if(output_function == 'scv_ms_anom_cs'){
    scv_output <- scv_ms_anom_cs(process_output = process_output,
                                 code_type = code_type,
                                 facet = facet,
                                 filter_concept = filter_concept,
                                 num_mappings = num_mappings)
  }else if(output_function == 'scv_ss_anom_cs'){
    scv_output <- scv_ss_anom_cs(process_output = process_output,
                                 code_type = code_type,
                                 filter_concept = filter_concept,
                                 facet = facet,
                                 num_codes = num_codes,
                                 num_mappings = num_mappings)
  }else if(output_function == 'scv_ms_exp_cs'){
    scv_output <- scv_ms_exp_cs(process_output = process_output,
                                code_type = code_type,
                                facet = facet,
                                num_codes = num_codes)
  }else if(output_function == 'scv_ss_exp_cs'){
    scv_output <- scv_ss_exp_cs(process_output = process_output,
                                code_type = code_type,
                                facet = facet,
                                num_codes = num_codes,
                                num_mappings = num_mappings)
  }else if(output_function == 'scv_ms_anom_la'){
    scv_output <- scv_ms_anom_la(process_output = process_output,
                                 code_type = code_type,
                                 filter_concept = filter_concept,
                                 filter_mapped = filter_mapped)
  }else if(output_function == 'scv_ss_anom_la'){
    scv_output <- scv_ss_anom_la(process_output = process_output,
                                 code_type = code_type,
                                 filter_concept = filter_concept,
                                 facet = facet)
  }else if(output_function == 'scv_ms_exp_la'){
    scv_output <- scv_ms_exp_la(process_output = process_output,
                                code_type = code_type,
                                filter_concept = filter_concept,
                                num_mappings = num_mappings,
                                facet = facet)
  }else if(output_function == 'scv_ss_exp_la'){
    scv_output <- scv_ss_exp_la(process_output = process_output,
                                code_type = code_type,
                                num_mappings = num_mappings,
                                facet = facet)
  }else(cli::cli_abort('Please enter a valid output function for this check type.'))

  return(scv_output)

}
